A book consists of chapters, chapters consist of sections and sections consist of subsections. Construct a tree and print the nodes. Find the time and space requirements of your method.#include<iostream>#include<string>using namespace std;struct node{string label;int count;node *child[50];};node*root;class tree{public:tree();void insert();void display();};tree::tree(){root=NULL;}void tree::insert(){root=new node();cout<<"enter name of book: ";getline(cin>>ws,root->label);cout<<"enter number of chapter : ";cin>>root->count;for(int i=0;i<root->count;i++){root->child[i]=new node();cout<<"enter name of chapter : ";getline(cin>>ws,root->child[i]->label);cout<<"enter number of section in chapter no "<<i+1<<": ";cin>>root->child[i]->count;for(int j =0;j<root->child[i]->count;j++){root->child[i]->child[j]=new node;cout<<"enter name of section : ";getline(cin>>ws,root->child[i]->child[j]->label);cout<<"enter number of subsection in chapter no "<<i+1<<": ";cin>>root->child[i]->child[j]->count;for(int k =0;k<root->child[i]->child[j]->count;k++){root->child[i]->child[j]->child[k]=new node;cout<<"enter name of subsection : ";getline(cin>>ws,root->child[i]->child[j]->child[k]->label);}}}}void tree::display() {if (root != NULL) {cout <<"\n\n--------------- Hierarchy of Book ---------------\n\n";cout <<"Book Name: "<< root->label << endl;for (int i = 0; i < root->count; i++) {cout <<"\n> "<< root->child[i]->label << endl;for (int j = 0; j < root->child[i]->count; j++) {cout <<"---> "<< root->child[i]->child[j]->label << endl;for (int k = 0; k < root->child[i]->child[j]->count; k++) {cout <<"------> "<< root->child[i]->child[j]->child[k]->label << endl;}}}}}int main() {tree g;int ch;do {cout <<"\nEnter choice\n1.input 2.display\nChoice [1/2] ";cin >> ch;switch (ch) {case 1:g.insert();break;case 2:g.display();break;}} while (ch < 3);return 0;}// Beginning with an empty binary search tree, Construct binary search tree by inserting the // values in the order given. After constructing a binary tree -// i. Insert new node // ii. Find number of nodes in longest path from root// iii. Minimum data value found in the tree // iv. Change a tree so that the roles of the left and right pointers are swapped at every // node #include<iostream>using namespace std;struct node{int data;node*left;node*right;};class bst{public:node*root;bst(){root=NULL;}node *create();node* insert(node *t,int x);void display(node *);node *findmin(node *);node *findmax(node *);int height(node *);node *search(node *,int );};node *bst::create(){int n,i,x;cout<<"Enter the number of node to be inserted";cin>>n;for(i=0;i<n;i++){cout<<"enter the value : ";cin>>x;root=insert(root,x);}return root;};node *bst::insert(node * t,int x){if(t==NULL){t=new node;t->data=x;t->left=NULL;t->right=NULL;return t;}else{if(x>t->data){t->right=insert(t->right,x);return t;}if(x<t->data){t->left=insert(t->left,x);return t;}}}void bst::display(node *t){if(t!=NULL){display(t->left);cout<<t->data<<" ";display(t->right);}}node *bst::findmin(node *t){while(t->left!=NULL){t=t->left;}return t;}node* bst::findmax(node *t){while (t->right!=NULL){t=t->right;}return t;}int bst::height(node *t){if(t==NULL){return 0;}else{return max(height(t->left),height(t->right)+1);}}node* bst::search(node *t,int x){if(t==NULL){return NULL;}if(x==t->data){cout<<"found..!";return t;}else{if(x>t->data){search(t->right,x);}if(x<t->data){search(t->left,x);}}}int main(){bst b1;int ch,x1;char ans;int key;node *temp,*temp1;do{cout<<" \n MAIN MENU \n 1. Create \n 2. Insert \n 3.Display \n 4.Findmin \n 5. Findmax \n 6.Find \n 7. Height";cout<<"\n\n Enter your choice : ";cin>>ch;switch(ch){case 1: b1.root=b1.create();break;case 2: cout<<"Enter Data : ";cin>>x1;b1.root=b1.insert(b1.root,x1);break;case 3: cout<<"THE BST TREE in INORDER : \n ";b1.display(b1.root);break;case 4: temp=b1.findmin(b1.root);cout<<"\n Min value from BST is :"<<temp->data;break;case 5: temp=b1.findmax(b1.root);cout<<"\n Max value from BST is :"<<temp->data;break;case 6: cout<<" \n Enter Key value to be search : ";cin>>key;temp1=b1.search(b1.root,key);if(temp1!=NULL)cout<<"Present "<<temp1->data;elsecout<<"\n Key is not Present in BST ";break;case 7: x1=b1.height(b1.root);cout<<" Height of BST tree is : "<<x1-1;break;}cout<<"\n \n Go to Main Menu ??(y or n) : ";cin>>ans;}while(ans=='y');return 0;}// A Dictionary stores keywords & its meanings. Provide facility for adding new keywords, // deleting keywords, updating values of any entry. Provide facility to display whole data // sorted in ascending/ Descending order. Also find how many maximum comparisons may // require for finding any keyword. Use Binary Search Tree for implementation.#include<iostream>using namespace std;#include<string.h>struct node{public:char k[20];char m[20];node*left;node*right;};class dict{public:node * root;dict(){root=NULL;}node*create();node* search(node*,char[]);void displaya(node*);void displayd(node*);int comparision();void display(node*);void insert(node*,node*);void update(node*,char[]);};node * dict::create(){int n,i;node*temp;temp=new node;temp->left=NULL;temp->right=NULL;cout<<"\nenter the key : ";cin>>temp->k;cout<<"\nenter meaning : ";cin>>temp->m;if(root==NULL){root=temp;}else{insert(root,temp);}}void dict::insert(node*root,node*temp){if(strcmp(root->k,temp->k)>0){if(root->left==NULL){root->left=temp;}else{insert(root->left,temp);}};if(strcmp(root->k,temp->k)<0){if(root->right==NULL){root->right=temp;}else{insert(root->right,temp);}}};void dict::display(node* root){if(root!=NULL){int ch;cout<<"\n1.asscending\n2.deccending";cin>>ch;if(ch==1){displaya(root);}if(ch==2){displayd(root);}}}void dict::displayd(node*root){if(root!=NULL){displayd(root->right);cout<<"\nkey: "<<root->k<<" meaning : "<<root->m;displayd(root->left);}}void dict::displaya(node*root){if(root!=NULL){displayd(root->left);cout<<"\nkey: "<<root->k<<" meaning : "<<root->m;displayd(root->right);}}node* dict::search(node* root,char a[]){int c=0;node*temp;temp=NULL;while(root!=NULL){c++;if(strcmp(root->k,a)==0){cout<<"\nkey is found..";cout<<"\nnumber of comparison required : "<<c;temp=root;return temp;}else{if(strcmp(root->k,a)<0){root=root->right;}if(strcmp(root->k,a)>0){root=root->left;}}}}void dict::update(node * root,char a[]){while(root!=NULL){if(strcmp(root->k,a)==0){char nm[20];cout <<"\nenter the new meaning : ";cin>>root->m;cout<<"\nmeaning updated..!\n";return;}else{if(strcmp(root->k,a)<0){root=root->right;}if(strcmp(root->k,a)>0){root=root->left;}}}}int main(){dict d;int ch,n;do{cout<<"\n1.create\n2.display\n3.search\n4.update\n";cin>>ch;switch(ch){case 1: cout<<"how many key to be inserted?? : ";int n;cin>>n;for(int i=0;i<n;i++){d.create();}break;case 2:cout<<"1.asscending\n2.deccesending";int h;cin>>h;if(h==1){d.displaya(d.root);break;}else{d.displayd(d.root);break;}case 3:char s[20];cout<<"enter key to be searched";cin>>s;d.search(d.root,s);break;case 4:cout<<"enter key ";char i[20];cin>>i; d.update(d.root,i);break;}cout<<"\ndo you want to continue?? ";cin>>n;}while(n==1);return 0;}There are flight paths between cities. If there is a flight between city A and city B then there is an edge between the cities. The cost of the edge can be the time that flight take to reach city B from A, or the amount of fuel used for the journey. Represent this as a graph. The node can be represented by airport name or name of the city. Use adjacency list representation of the graph or use adjacency matrix representation of the graph. Check whether the graph is connected or not. Justify the storage representation used.#include<iostream>#include<string.h>using namespace std;class flight{public:int am[10][10];char city_index[10][10];flight();int create();void display(int city_count);};flight::flight(){int i,j;for(i=0;i<10;i++){strcpy(city_index[i],"xx");}for(i=0;i<10;i++){for(j=0;j<10;j++){am[i][j]=0;}}}int flight::create(){int city_count=0,j,si,di,wt;char s[10],d[10],c;do{cout<<"\n\tEnter Source City : ";cin>>s;cout<<"\n\tEnter Destination City : ";cin>>d;for(j=0;j<10;j++){if(strcmp(city_index[j],s)==0)break;}if(j==10){strcpy(city_index[city_count],s);city_count++;}for(j=0;j<10;j++){if(strcmp(city_index[j],d)==0)break;}if(j==10){strcpy(city_index[city_count],d);city_count++;}cout<<"\n\t Enter Distance From "<<s<<" And "<<d<<": ";cin>>wt;for(j=0;j<10;j++){if(strcmp(city_index[j],s)==0)si=j;if(strcmp(city_index[j],d)==0)di=j;}am[si][di]=wt;cout<<"\n\t Do you want to add more cities.....(y/n) : ";cin>>c;}while(c=='y'||c=='Y');return(city_count);}void flight::display(int city_count){int i,j;cout<<"\n\t Displaying Adjacency Matrix :\n\t";for(i=0;i<city_count;i++)cout<<"\t"<<city_index[i];cout<<"\n";for(i=0;i<city_count;i++){cout<<"\t"<<city_index[i];for(j=0;j<city_count;j++){cout<<"\t"<<am[i][j];}cout<<"\n";}}int main(){flight f;int n,city_count;char c;do{cout<<"\n\t*** Flight Main Menu *****";cout<<"\n\t1. Create \n\t2. Adjacency Matrix\n\t3. Exit";cout<<"\n\t.....Enter your choice : ";cin>>n;switch(n){case 1:city_count=f.create();break;case 2:f.display(city_count);break;case 3:return 0;}cout<<"\n\t Do you Want to Continue in Main Menu....(y/n) : ";cin>>c;}while(c=='y'||c=='Y');return 0;}You have a business with several offices; you want to lease phone lines to connect them up with each other; and the phone company charges different amounts of money to connect different pairs of cities. You want a set of lines that connects all your offices with a minimum total cost. Solve the problem by suggesting appropriate data structures.#include <iostream>#include <limits.h>using namespace std;class Office {int n;int adjacent[10][10];string office[10];public:void input ();void display ();void Prims ();};void Office::input () {cout << "\nEnter no. of offices: ";cin >> n;cout << "\nEnter the names of offices: ";for (int i = 0 ; i < n ; i++)cin >> office[i];cout << "\nEnter the cost to connect the offices: \n";for (int i = 0 ; i < n ; i++)for (int j = i ; j < n ; j++) {if (i == j) {adjacent[i][j] = 0;continue;}cout << "Enter the cost to connect " << office[i] <<" and " <<office[j]<< " : ";cin >> adjacent[i][j];adjacent[j][i] = adjacent[i][j];}}void Office::display () {for (int i = 0 ; i < n ; i++) {cout << "\n";for (int j = 0 ; j < n ; j++) {cout << adjacent[i][j] << "\t";}}}void Office::Prims () {int visit[n], minCost = 0, count = n - 1, minIndex, cost = 0;for (int i = 0 ; i < n ; i++)visit[i] = 0;cout << "\n\nShortest path: ";visit[0]=1;cout << office[0] << " -> ";while (count--) {minCost = INT_MAX;for (int i = 0 ; i < n ; i++) {for (int j = 0 ; j < n ; j++) {if (visit[i] == 1 && adjacent[i][j] != 0 && adjacent[i][j] < minCost && visit[j] == 0) {minCost = adjacent[i][j];minIndex = j;}}}visit[minIndex]=1;cout << office[minIndex] << " -> ";cost = cost + minCost;}cout << "End";cout << "\nMinimum cost: "<<cost;}int main () {Office o1;int choice;do {cout << "\n\nMINIMUM SPANNING TREE"<< "\n1. Input data"<< "\n2. Display data"<< "\n3. Calculate minimum cost"<< "\nEnter your choice: ";cin >> choice;switch (choice) {case 1:o1.input ();break;case 2:o1.display ();break;case 3:o1.Prims ();break;}} while (choice != 4);return 0;}obst#include<iostream>using namespace std;void con();void print(int,int);float a[20],b[20],wt[20][20],c[20][20];int r[20][20],n;int main(){int i;cout<<"\n******PROGRAM FOR OBST******\n";cout<<"\n Enter the no of nodes:";cin>>n;cout<<"\n Enter the probability of successful search:";for(i=1;i<=n;i++){cout<<"p["<<i<<"]";cin>>a[i];}cout<<"enter the probability of unsuccessful search:";cout<<"\n***************************************\n";for(i=0;i<=n;i++){cout<<"q["<<i<<"]";cin>>b[i];}con();print(0,n);cout<<endl;}void con(){int i,j,k,l,min;for(i=0;i<n;i++){c[i][i]=0.0;r[i][j]=0;wt[i][j]=b[i];wt[i][i+1]=b[i]+b[i+1]+a[i+1];c[i][i+1]=b[i]+b[i+1]+a[i+1];r[i][i+1]=i+1;}c[n][n]=0;r[n][n]=0;wt[n][n]=b[n];for(i=2;i<=n;i++){for(j=0;j<=n-i;j++){wt[j][j+i]=b[j+i]+a[j+i]+wt[j][j+i-1];c[j][j+i]=999999;for(l=j+1;l<j+i;l++){if(c[j][j+i]>(c[j][l-1]+c[l][j+i])){c[j][j+i]=c[j][l-1]+c[l][l+i];r[i][j+i]=l;}}c[j][j+i]+=wt[j][j+i];}cout<<endl;}cout<<"\n\noptimal bst is ::";cout<<"\n\nw[0]["<<n<<"]:"<<wt[0][n];cout<<"\nc[0]["<<n<<"]:"<<c[0][n];cout<<"\nr[0]["<<n<<"]:"<<r[0][n];}void print(int l1,int r1){if(l1>=r1){return;}if(r[l1][r[l1][r1]-1]!=0){cout<<"\nleft child of "<<r[l1][r1]<<"::"<<r[l1][r[l1][r1]-1];}if(r[r[l1][r1]][l1]!=0){cout<<"\nright child of "<<r[l1][r1]<<"::"<<r[r[l1][r1]][l1];}print(l1,r[l1][r1]-1);print(r[l1][r1],r1);return;}Read the marks obtained by students of second year in an online examination of particular subject. Find out maximum and minimum marks obtained in that subject. Use heap data structure. Analyze the algorithm.#include<iostream>using namespace std;# define max 20class stud{int mks[max];public:stud(){for(int i=0;i<max;i++)mks[i]=0;}void insertheap(int tot);void displayheap(int tot);void showmax(int tot);void showmin();};void stud::insertheap(int tot){for(int i=1;i<=tot;i++){cout<<"enter marks";cin>>mks[i];int j=i;int parent=j/2;while(mks[j]<=mks[parent] && j!=0){int tmp = mks[j];mks[j]=mks[parent];mks[parent]=tmp;j=parent;parent=j/2;} }}void stud::displayheap(int tot){int i=1,space=6;cout<<endl;while(i<=tot){if(i==1 || i==2 || i==4 || i==8 || i==16){cout<<endl<<endl;for(int j=0;j<space;j++)cout<<" ";space-=2; }cout<<" "<<mks[i];i++;}}void stud::showmax(int tot){int max1=mks[1];for(int i=2;i<=tot;i++){if(max1<mks[i])max1= mks[i];}cout<<"Max marks:"<<max1;}void stud::showmin(){cout<<"Min marks:"<<mks[1];}int main(){int ch,cont,total,tmp;int n;stud s1;do{cout<<endl<<"Menu";cout<<endl<<"1.Read marks of the student ";cout<<endl<<"2.Display Min heap";cout<<endl<<"3.Find Max Marks";cout<<endl<<"4.Find Min Marks";cout<<endl<<"Enter Choice";cin>>ch;switch(ch){case 1:cout<<"how many students";cin>>total;s1.insertheap(total);break;case 2:s1.displayheap(total);break;case 3: s1.showmax(total);break;case 4:s1.showmin();break;}cout<<endl<<"do u want to continue?(1 for continue)";cin>>cont;}while(cont==1);return 0;}Department maintains a student information. The file contains roll number, name, division and address. Allow user to add, delete information of student. Display information of particular employee. If record of student does not exist an appropriate message is displayed. If it is, then the system displays the student details. Use sequential file to main the data.#include<iostream>#include<fstream>using namespace std;class record{int roll;int div;string name;string address;public:void getdata();void putdata();int getroll();record();};record::record(){roll=0;div=0;name=" ";address=' ';}void record::getdata(){cout<<"Enter roll number : ";cin>>roll;cout<<"enter division : ";cin>>div;cout<<"Enter name : ";cin>>name;cout<<"enter address : ";cin>>address;}void record::putdata(){cout<<" roll number : ";cout<<roll<<endl;cout<<"division : " ;cout<<div<<endl;cout<<" name : ";cout<<name<<endl;cout<<"address : ";cout<<address<<endl;}int record::getroll(){return roll;}class file{ifstream fin;ofstream fout;fstream fs;public:void insert();void display();int search(int roll);int edit(int roll);int delet(int roll);};void file::insert(){record r;r.getdata();fout.open("studentdb",ios::ate|ios::app);fout.write((char*)&r,sizeof(r));fout.close();}void file::display(){record r;fin.open("studentdb");fin.seekg(0,ios::beg);while(fin.read((char*)&r,sizeof(r))){r.putdata();}fin.close();}int file::search(int roll){record r;int flag=0;fin.open("studentdb");fin.seekg(0,ios::beg);while(fin.read((char*)&r,sizeof(r))){if(r.getroll()==roll){flag=1;break;}}fin.close();if(flag==1){cout<<"\nrecord found\n";r.putdata();}else{cout<<"\nrecord not found ...!";}return flag;}int file::edit(int roll){record r;int flag =0;fs.open("studentdb");fs.seekg(0,ios::beg);while(fs.read((char*)&r,sizeof(r))){if(r.getroll()==roll){flag=1;cout<<"enter new details : ";r.getdata();fs.seekp((int)fin.tellg()-sizeof(r),ios::beg);fs.write((char*)&r,sizeof(r));}}fs.close();return flag;}int file::delet(int roll){record r;int flag;fout.open("temp",ios::ate|ios::app);fin.open("studentdb");fin.seekg(0,ios::beg);while(fin.read((char*)&r,sizeof(r))){if(r.getroll()==roll){flag=1;}else{fout.write((char*)&r,sizeof(r));}}fout.close();fin.close();remove("studentdb");rename("temp","studentdb");}int main() {file f;int ch, n, i, flag = 0;do {cout << "\n\n\t-----M E N U-----";cout << "\n\n1. Build A Master Table";cout << "\n2. List A Table";cout << "\n3. Insert a New Entry";cout << "\n4. Delete Old Entry";cout << "\n5. Edit an Entry";cout << "\n6. Search for a Record";cout << "\n7. Quit";cout << "\nEnter your Choice: ";cin >> ch;switch (ch) {case 1:if (flag == 0) {cout << "\nEnter No of Records to insert : ";cin >> n;for (i = 0; i < n; i++) {f.insert();}flag = 1;}else {cout << "\nSorry.. Table is Already build... \n If want to add record please select Insert a New Entry in option.....";}break;case 2:f.display();break;case 3:f.insert();break;case 4:cout << "\nEnter Roll No of Student Whose Record is to be Deleted: ";cin >> n;i = f.delet(n);if (i == 1)cout << "\nRecord Deleted Successfully";elsecout << "\nRecord not Found";break;case 5:cout << "\nEnter Roll No of Student Whose Record is to be Edit: ";cin >> n;i = f.edit(n);if (i == 1)cout << "\nRecord Modified Successfully";elsecout << "\nRecord not Found";break;case 6:cout << "\nEnter Roll No of Student Whose Record is to be Searched: ";cin >> n;f.search(n);break;case 7:break;default:cout << "\nEnter Valid Choice.....";}} while (ch != 7);return (0);}Company maintains employee information as employee ID, name, designation and salary. Allow user to add, delete information of employee. Display information of particular employee. If employee does not exist an appropriate message is displayed. If it is, then the system displays the employee details. Use index sequential file to maintain the data.#include <iostream>#include <fstream>using namespace std;class Record {int id;string name;int salary;string designation;public:Record();int getIdno();void getData();void putData();};Record::Record() {id = 0;name = ' ';designation = ' ';salary = 0;}int Record::getIdno() {return (id);}void Record::getData() {cout << "\nEnter Details: ";cout << "\nId no: ";cin >> id;cout << "Name: ";cin >> name;cout << "Salary: ";cin >> salary;cout << "Designation: ";cin >> designation;}void Record::putData() {cout << "\nId No.: ";cout << id;cout << "\t\tName: ";cout << name;cout << "\nSalary: ";cout << salary;cout << "\tDesignation: ";cout << designation;}class File {ifstream fin;ofstream fout;fstream fs;public:void insert();void display();void search(int);int Delete(int);int edit(int);};void File::insert() {Record r;r.getData();fout.open("EmployeeDB", ios::ate | ios::app);fout.write((char *)&r, sizeof(r));fout.close();}void File::display() {Record r;fin.open("EmployeeDB");fin.seekg(0, ios::beg);while (fin.read((char *)&r, sizeof(r)))r.putData();fin.close();}void File::search(int id) {Record r;int flag = 0;fin.open("EmployeeDB");fin.seekg(0, ios::beg);while (fin.read((char *)&r, sizeof(r))) {if (r.getIdno() == id) {flag = 1;break;}}fin.close();if (flag == 1) {cout << "\nRecord Found:";r.putData();}elsecout << "\nRecord not Found ";}int File::Delete(int id) {Record r;int flag = 0;fin.open("EmployeeDB");fout.open("Temp", ios::ate | ios::app);fin.seekg(0, ios::beg);while (fin.read((char *)&r, sizeof(r))) {if (r.getIdno() == id) {flag = 1;}else {fout.write((char *)&r, sizeof(r));}}fin.close();fout.close();remove("EmployeeDB");rename("Temp", "EmployeeDB");return (flag);}int File::edit(int id) {Record r;int flag = 0;fs.open("EmployeeDB");fs.seekg(0, ios::beg);while (fs.read((char *)&r, sizeof(r))) {if (r.getIdno() == id) {flag = 1;cout << "\nEnter New Details: ";r.getData();fs.seekp((int)fs.tellg() - sizeof(r), ios::beg);fs.write((char *)&r, sizeof(r));}}fs.close();return (flag);}int main() {File f;int ch, n, i, flag = 0;do {cout << "\n\n\t-----M E N U-----";cout << "\n\n1. Build A Master Table";cout << "\n2. List A Table";cout << "\n3. Insert a New Entry";cout << "\n4. Delete Old Entry";cout << "\n5. Edit an Entry";cout << "\n6. Search for a Record";cout << "\n7. Quit";cout << "\nEnter your Choice: ";cin >> ch;switch (ch) {case 1:if (flag == 0) {cout << "\nEnter No of Records to insert : ";cin >> n;for (i = 0; i < n; i++) {f.insert();}flag = 1;}else {cout << "\nSorry.. Table is Already build... \n If want to add record please select Insert a New Entry in option.....";}break;case 2:f.display();break;case 3:f.insert();break;case 4:cout << "\nEnter Id No of Employee Whose Record is to be Deleted: ";cin >> n;i = f.Delete(n);if (i == 1)cout << "\nRecord Deleted Successfully";elsecout << "\nRecord not Found";break;case 5:cout << "\nEnter Id No of Employee Whose Record is to be Edit: ";cin >> n;i = f.edit(n);if (i == 1)cout << "\nRecord Modified Successfully";elsecout << "\nRecord not Found";break;case 6:cout << "\nEnter Id No of Employee Whose Record is to be Searched: ";cin >> n;f.search(n);break;case 7:break;default:cout << "\nEnter Valid Choice.....";}} while (ch != 7);return (0);}
